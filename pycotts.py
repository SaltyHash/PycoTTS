"""
Converts text to speech using `pico2wave` and `aplay`.

Prerequisites:
1. pico2wave is installed and working (package is named 'libttspico-utils' on Debian).
2. aplay is installed and working (package is named 'alsa-utils' on Debian).
For example, on Debian, these packages could be installed using:
    $ sudo apt-get install libttspico-utils alsa-utils
"""

import subprocess

from collections import namedtuple
from queue import Queue
from tempfile import NamedTemporaryFile
from threading import Thread

Message = namedtuple('Message', ('text', 'language', 'volume', 'pitch', 'speed'))


class _PycoTTSWorker(Thread):
    def __init__(self, queue: Queue):
        Thread.__init__(self, name=self.__class__.__name__, daemon=False)
        self.queue = queue

    def _print(self, message, *args, **kwargs):
        print(f'[{self.name}] {message}', *args, **kwargs)

    def _run_command(self, command):
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)

        if result.returncode != 0:
            self._print(f'ERROR: Failed to execute command (exit code {result.returncode}): {command}')
            self._print(f'Output:')
            for line in result.stdout.splitlines():
                self._print('  ' + line)
            return False

        return True

    def run(self):
        if self.queue.empty():
            return

        # Create a new temporary wav file
        with NamedTemporaryFile(prefix='pycotts-', suffix='.wav') as wav_file:
            while not self.queue.empty():
                # Grab the next message from the queue
                message = self.queue.get_nowait()

                # Build message text
                message_text = message.text
                if message.volume is not None:
                    message_text = f'<volume level=\'{message.volume}\'>{message_text}</volume>'
                if message.pitch is not None:
                    message_text = f'<pitch level=\'{message.pitch}\'>{message_text}</pitch>'
                if message.speed is not None:
                    message_text = f'<speed level=\'{message.speed}\'>{message_text}</speed>'

                # Run pico2wave to generate the TTS wav file
                pico2wave_args = ['pico2wave', '-w', wav_file.name]
                if message.language is not None:
                    pico2wave_args += ['-l', message.language]
                pico2wave_args.append(message_text)
                # pico2wave failed?
                if not self._run_command(pico2wave_args):
                    continue

                # Play the wav file generated by pico2wave
                self._run_command(['aplay', wav_file.name])

        self.queue = None


class PycoTTS(object):
    language: str = None
    volume: int = None
    pitch: int = None
    speed: int = None

    def __init__(self, language: str = None, volume: int = None, pitch: int = None, speed: int = None):
        self.language = language
        self.volume = volume
        self.pitch = pitch
        self.speed = speed

        self.__message_queue = Queue()
        self.__worker: Thread = None

    def speak(
            self, message_text: str,
            language: str = None, volume: int = None, pitch: int = None, speed: int = None,
            wait: bool = True, timeout: float = None
    ):
        # Build the message object
        message = Message(
            message_text,
            self.language if language is None else language,
            self.volume if volume is None else volume,
            self.pitch if pitch is None else pitch,
            self.speed if speed is None else speed
        )

        # Add the message to the queue
        self.__message_queue.put(message)

        # Launch a worker, if necessary
        if self.__worker is None or not self.__worker.is_alive():
            self.__worker = _PycoTTSWorker(self.__message_queue)
            self.__worker.start()

        # Wait until all messages have been processed, if told to do so
        if wait:
            return self.wait(timeout)

        # Success
        return True

    def wait(self, timeout: float = None):
        """
        Waits until all messages are done speaking, or a timeout occurs.
        :param timeout: Time in seconds to wait before returning `False`. `None` means no timeout.
        :return: `True` if done waiting, `False` if timeout occurred.
        """
        worker = self.__worker
        if worker is None:
            return True

        worker.join(timeout)
        if worker.is_alive():
            return False

        self.__worker = None
        return True


def main():
    tts = PycoTTS(
        language='en-GB',
        volume=65,
        pitch=110,
        speed=110
    )

    while True:
        message_text = input('Speak: ')
        if not message_text:
            break

        tts.speak(message_text, wait=False)
    tts.wait()


if __name__ == '__main__':
    main()
