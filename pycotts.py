"""
Converts text to speech using `pico2wave` and `aplay`.

Prerequisites:
1. pico2wave is installed and working (package is named 'libttspico-utils' on Debian).
2. aplay is installed and working (package is named 'alsa-utils' on Debian).
For example, on Debian, these packages could be installed using:
    $ sudo apt-get install libttspico-utils alsa-utils
"""

import re
import subprocess

from collections import namedtuple
from queue import Empty, Queue
from shutil import which
from tempfile import NamedTemporaryFile
from threading import Thread
from typing import Iterable, Tuple

_Message = namedtuple('_Message', ('text', 'language', 'volume', 'pitch', 'speed'))


class _PycoTTSWorker(Thread):
    __slots__ = (
        'queue'
    )

    def __init__(self, queue: Queue):
        Thread.__init__(self, name=self.__class__.__name__, daemon=False)
        self.queue = queue

    def _print(self, message, *args, **kwargs):
        print(f'[{self.name}] {message}', *args, **kwargs)

    def _run_command(self, command):
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)

        if result.returncode != 0:
            self._print(f'ERROR: Failed to execute command (exit code {result.returncode}): {command}')
            self._print(f'Output:')
            for line in result.stdout.splitlines():
                self._print('  ' + line)
            return False

        return True

    def run(self):
        if self.queue.empty():
            return

        # Create a new temporary wav file
        with NamedTemporaryFile(prefix='pycotts-', suffix='.wav') as wav_file:
            while True:
                # Grab the next message from the queue, or break if it is empty
                try:
                    message = self.queue.get_nowait()
                except Empty:
                    break

                # Build message text
                message_text = message.text
                if message.volume is not None:
                    message_text = f'<volume level=\'{message.volume}\'>{message_text}</volume>'
                if message.pitch is not None:
                    message_text = f'<pitch level=\'{message.pitch}\'>{message_text}</pitch>'
                if message.speed is not None:
                    message_text = f'<speed level=\'{message.speed}\'>{message_text}</speed>'

                # Run pico2wave to generate the TTS wav file
                pico2wave_args = ['pico2wave', '-w', wav_file.name]
                if message.language is not None:
                    pico2wave_args += ['-l', message.language]
                pico2wave_args.append(message_text)
                # pico2wave failed?
                if not self._run_command(pico2wave_args):
                    continue

                # Play the wav file generated by pico2wave
                self._run_command(['aplay', wav_file.name])


class ExecutableNotFoundError(Exception):
    __slots__ = (
        'executable'
    )

    def __init__(self, executable: str):
        Exception.__init__(self, f'Could not find executable "{executable}".')
        self.executable = executable


class PycoTTS(object):
    __slots__ = (
        'language',
        'volume',
        'pitch',
        'speed',
        'replacements',

        '__message_queue',
        '__worker'
    )

    def __init__(self, language: str = None, volume: int = None, pitch: int = None, speed: int = None):
        """
        :raises ExecutableNotFoundError: pico2wave or aplay executable could not be found.
        """
        # Make sure pico2wave and aplay exist
        for executable in ('pico2wave', 'aplay'):
            if not which(executable):
                raise ExecutableNotFoundError(executable)

        self.language = language
        self.volume = volume
        self.pitch = pitch
        self.speed = speed

        self.replacements = []

        self.__message_queue = Queue()
        self.__worker: Thread = None

    def add_replacement(self, pattern: str, replacement: str):
        """
        All occurrences of the `pattern` will be replaced by the `replacement` string before speaking a message.

        :param pattern: Regex pattern to be replaced.
        :param replacement: Text to be substituted in for the pattern.
        """
        self.replacements.append((pattern, replacement))

    def add_replacements(self, replacements: Iterable[Tuple[str, str]]):
        self.replacements.extend(replacements)

    def speak(
            self, message_text: str,
            language: str = None, volume: int = None, pitch: int = None, speed: int = None,
            wait: bool = True, timeout: float = None
    ):
        # Make replacements
        for pattern, replacement in self.replacements:
            message_text = re.sub(pattern, replacement, message_text)

        # Build the message object
        message = _Message(
            message_text,
            self.language if language is None else language,
            self.volume if volume is None else volume,
            self.pitch if pitch is None else pitch,
            self.speed if speed is None else speed
        )

        # Add the message to the queue
        self.__message_queue.put(message)

        # Launch a worker, if necessary
        if self.__worker is None or not self.__worker.is_alive():
            self.__worker = _PycoTTSWorker(self.__message_queue)
            self.__worker.start()

        # Wait until all messages have been processed, if told to do so
        if wait:
            return self.wait(timeout)

        # Success
        return True

    def wait(self, timeout: float = None):
        """
        Waits until all messages are done speaking, or a timeout occurs.
        :param timeout: Seconds to wait before returning `False`. `None` means no timeout.
        :return: `True` if done waiting, `False` if timeout occurred.
        """
        worker = self.__worker
        if worker is None:
            return True

        worker.join(timeout)
        if worker.is_alive():
            return False

        self.__worker = None
        return True


def main():
    tts = PycoTTS(
        language='en-GB',
        volume=65,
        pitch=110,
        speed=110
    )

    while True:
        message_text = input('Speak: ')
        if not message_text:
            break

        tts.speak(message_text, wait=False)
    tts.wait()


if __name__ == '__main__':
    main()
